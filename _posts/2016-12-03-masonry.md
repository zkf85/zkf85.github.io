---
layout: post
title: "Masonry"
date: "2016-12-03 21:18:00"
category: [iOS Development]
tags: [ios, objective-c, masonry, autolayout]
---
<div class = "message">
Use Masonry to implement autolayout programmatically. Learn how to use it. A detailed note here!
</div>

> Harness the power of AutoLayout NSLayoutConstraints with a simplified, chainable and expressive syntax. Supports iOS and OSX Auto Layout[^masonry]

The content below is my notes from reading Introduction on Masonry's Github Page[^masonry]

## Why use Masonry?
Under the hood Auto Layout is a powerful and flexible way of organising and laying out your views. However **creating constraints from code is verbose and not very descriptive**. Imagine a simple example in which you want to have a view fill its superview but inset by 10 pixels on every side

<!--more-->

## Prepare to meet your Maker!
Create constraints using MASConstraintMaker:

```objc
UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);

[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(superview.mas_top).with.offset(padding.top); //with is an optional semantic filler
    make.left.equalTo(superview.mas_left).with.offset(padding.left);
    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);
    make.right.equalTo(superview.mas_right).with.offset(-padding.right);
}];
```

Or even shorter

```objc
[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(superview).with.insets(padding);
}];
```

#### IMPORTANT NOTES:
> 1. We had to add the constraints to the superview [superview addConstraints:.... using autolayout. Masonry however will **automagically add constraints to the appropriate view**.
> 
> 2. Masonry will also **automagically** call `view1.translatesAutoresizingMaskIntoConstraints = NO;` for you.

Not all things are created equal

.`equalTo` equivalent to NSLayoutRelationEqual

.`lessThanOrEqualTo` equivalent to NSLayoutRelationLessThanOrEqual

.`greaterThanOrEqualTo` equivalent to NSLayoutRelationGreaterThanOrEqual
These three equality constraints accept one argument which can be any of the following:

### 1. MASViewAttribute
```make.centerX.lessThanOrEqualTo(view2.mas_left);```

### 2. UIView/NSView

if you want `view.left` to be greater than or equal to `label.left` :

```objc
//these two constraints are exactly the same
make.left.greaterThanOrEqualTo(label);
make.left.greaterThanOrEqualTo(label.mas_left);
```

### 3. NSNumber

Auto Layout allows width and height to be set to constant values. if you want to set view to have a minimum and maximum width you could pass a number to the equality blocks:

```objc
//width >= 200 && width <= 400
make.width.greaterThanOrEqualTo(@200);
make.width.lessThanOrEqualTo(@400);
```

However Auto Layout does not allow alignment attributes such as left, right, centerY etc to be set to constant values. So if you pass a NSNumber for these attributes Masonry will turn these into constraints relative to the view’s superview ie:

```objc
//creates view.left = view.superview.left + 10
make.left.lessThanOrEqualTo(@10)
```

Instead of using NSNumber, you can use primitives and structs to build your constraints, like so:

```objc
make.top.mas_equalTo(42);
make.height.mas_equalTo(20);
make.size.mas_equalTo(CGSizeMake(50, 100));
make.edges.mas_equalTo(UIEdgeInsetsMake(10, 0, 10, 0));
make.left.mas_equalTo(view).mas_offset(UIEdgeInsetsMake(10, 0, 10, 0));
```

By default, macros which support autoboxing are prefixed with mas_. Unprefixed versions are available by defining MAS_SHORTHAND_GLOBALS before importing Masonry.

### 4. NSArray

An array of a mixture of any of the previous types

```objc
make.height.equalTo(@[view1.mas_height, view2.mas_height]);
make.height.equalTo(@[view1, view2]);
make.left.equalTo(@[view1, @100, view3.right]);
```

## Where should I create my constraints?

```objc
@implementation DIYCustomView

- (id)init {
    self = [super init];
    if (!self) return nil;

    // --- Create your views here ---
    self.button = [[UIButton alloc] init];

    return self;
}

// tell UIKit that you are using AutoLayout
+ (BOOL)requiresConstraintBasedLayout {
    return YES;
}

// this is Apple's recommended place for adding/updating constraints
- (void)updateConstraints {

    // --- remake/update constraints here
    [self.button remakeConstraints:^(MASConstraintMaker *make) {
        make.width.equalTo(@(self.buttonSize.width));
        make.height.equalTo(@(self.buttonSize.height));
    }];

    //according to apple super should be called at end of method
    [super updateConstraints];
}

- (void)didTapButton:(UIButton *)button {
    // --- Do your changes ie change variables that affect your layout etc ---
    self.buttonSize = CGSize(200, 200);

    // tell constraints they need updating
    [self setNeedsUpdateConstraints];
}

@end
```



## 中文资料[^liuyanwei] [^lijichuan]

#### [Masonry的使用 - 刘彦玮](http://liuyanwei.jumppo.com/2015/06/14/ios-library-masonry.html)

#### [Masonry介绍与使用实践(快速上手Autolayout) - 里脊串](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)

<br><br>
***KF***

## Reference
[^masonry]: [Masonry - Github](https://github.com/SnapKit/Masonry)
[^liuyanwei]: [Masonry的使用 - 刘彦玮](http://liuyanwei.jumppo.com/2015/06/14/ios-library-masonry.html)
[^lijichuan]: [Masonry介绍与使用实践(快速上手Autolayout) - 里脊串](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)